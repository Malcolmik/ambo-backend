generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================

enum Role {
  SUPER_ADMIN
  ADMIN                   // NEW: Middle-tier operations manager
  WORKER
  CLIENT_VIEWER
  CLIENT_VIEWER_PENDING
}

enum ClientStatus {
  LEAD
  ACTIVE
  PAUSED
  CLOSED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum TaskStatus {
  NOT_STARTED
  IN_PROGRESS
  WAITING
  DONE
  REJECTED
}

enum ClientApprovalStatus {
  PENDING
  APPROVED
  REVISION_REQUESTED
}

enum PaymentStatus {
  INITIATED
  PENDING
  PAID
  FAILED
  CANCELLED
}

enum ContractStatus {
  ACTIVE
  AWAITING_PAYMENT
  AWAITING_QUESTIONNAIRE
  READY_FOR_ASSIGNMENT
  IN_PROGRESS
  ON_HOLD
  COMPLETE
  CANCELLED
}

enum PaymentProvider {
  PAYSTACK
}

// NEW: Job Broadcasting Status
enum JobStatus {
  DRAFT           // Task created but not broadcasted
  OPEN            // Available for workers to apply
  REVIEWING       // Has applications, under review
  ASSIGNED        // Worker approved and assigned
  IN_PROGRESS     // Work started
  PENDING_REVIEW  // Awaiting admin approval of work
  COMPLETED       // Done
  CANCELLED       // Cancelled
}

// NEW: Application Status
enum ApplicationStatus {
  PENDING         // Awaiting review
  APPROVED        // Selected for the job
  REJECTED        // Not selected
  WITHDRAWN       // Worker withdrew interest
}

// NEW: Worker Payment Status (for earnings tracking)
enum WorkerPaymentStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
}

// ============================================
// USER MODEL
// ============================================

model User {
  id               String    @id @default(cuid())
  name             String
  email            String    @unique
  phone            String?
  passwordHash     String
  role             Role
  active           Boolean   @default(true)
  resetToken       String?   @unique
  resetTokenExpiry DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  clients       Client[]       @relation("ClientLinkedUser")
  tasksAssigned Task[]         @relation("TaskAssignedTo")
  tasksCreated  Task[]         @relation("TaskCreatedBy")
  tasksPaidBy   Task[]         @relation("TaskPaidBy")      // NEW: Tasks this user marked as paid
  comments      TaskComment[]
  updates       TaskUpdate[]
  auditLogs     AuditLog[]
  payments      Payment[]
  notifications Notification[]
  files         File[]

  workerChats ChatChannel[] @relation("WorkerChats")
  messages    Message[]

  // NEW: Job Applications
  jobApplications       JobApplication[] @relation("WorkerApplications")
  reviewedApplications  JobApplication[] @relation("ApplicationReviewer")
}

// ============================================
// CLIENT MODEL
// ============================================

model Client {
  id            String       @id @default(cuid())
  companyName   String
  contactPerson String
  email         String
  phone         String
  whatsapp      String?
  logoUrl       String?
  status        ClientStatus @default(LEAD)
  notes         String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  linkedUserId String?
  linkedUser   User?   @relation("ClientLinkedUser", fields: [linkedUserId], references: [id])

  // Relations
  tasks        Task[]
  contracts    Contract[]
  chatChannels ChatChannel[]
}

// ============================================
// CONTRACT MODEL
// ============================================

model Contract {
  id       String @id @default(cuid())
  clientId String
  client   Client @relation(fields: [clientId], references: [id])
  tasks    Task[]

  packageType String
  services    Json
  totalPrice  Float
  currency    String @default("NGN")

  paymentStatus PaymentStatus  @default(PENDING)
  status        ContractStatus @default(AWAITING_PAYMENT)

  paymentRef     String? @unique
  chatChannelUrl String? @db.VarChar(191)

  // Relations
  payments      Payment[]
  questionnaire Questionnaire?
  review        Review?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============================================
// TASK MODEL (Updated with Job Broadcasting)
// ============================================

model Task {
  id                   String               @id @default(cuid())
  title                String
  description          String
  priority             TaskPriority         @default(MEDIUM)
  status               TaskStatus           @default(NOT_STARTED)
  clientApprovalStatus ClientApprovalStatus @default(PENDING)
  dueDate              DateTime?
  requiresApproval     Boolean              @default(false)
  meta                 Json?
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt

  clientId String?
  client   Client? @relation(fields: [clientId], references: [id])

  contractId String?
  contract   Contract? @relation(fields: [contractId], references: [id])

  assignedToId String?
  assignedTo   User?   @relation("TaskAssignedTo", fields: [assignedToId], references: [id])

  createdById String
  createdBy   User   @relation("TaskCreatedBy", fields: [createdById], references: [id])

  // NEW: Job Broadcasting Fields
  jobStatus   JobStatus @default(DRAFT)    // Broadcasting status
  isPublic    Boolean   @default(false)    // Visible in job board
  postedAt    DateTime?                    // When pushed to broadcast
  deadline    DateTime?                    // Application deadline

  // NEW: Worker Payment/Earnings Fields
  paymentAmount       Decimal?            @db.Decimal(10, 2)  // Amount worker earns (NGN)
  workerPaymentStatus WorkerPaymentStatus @default(PENDING)
  paidAt              DateTime?
  paidById            String?
  paidBy              User?               @relation("TaskPaidBy", fields: [paidById], references: [id])

  // Relations
  comments     TaskComment[]
  updates      TaskUpdate[]
  applications JobApplication[]  // NEW: Workers who applied

  @@index([jobStatus, isPublic])
  @@index([assignedToId, status])
  @@index([workerPaymentStatus])
}

// ============================================
// NEW: JOB APPLICATION MODEL
// ============================================

model JobApplication {
  id              String            @id @default(cuid())
  
  taskId          String
  task            Task              @relation(fields: [taskId], references: [id], onDelete: Cascade)
  
  workerId        String
  worker          User              @relation("WorkerApplications", fields: [workerId], references: [id])
  
  status          ApplicationStatus @default(PENDING)
  coverNote       String?           @db.Text      // Worker's pitch/message
  
  appliedAt       DateTime          @default(now())
  reviewedAt      DateTime?
  reviewedById    String?
  reviewedBy      User?             @relation("ApplicationReviewer", fields: [reviewedById], references: [id])
  rejectionReason String?

  @@unique([taskId, workerId])  // One application per worker per task
  @@index([taskId, status])
  @@index([workerId, status])
}

// ============================================
// NEW: PLATFORM SETTINGS MODEL
// ============================================

model PlatformSettings {
  id               String   @id @default("default")
  
  // Support Channels
  supportWhatsapp  String?
  supportEmail     String?
  supportInstagram String?
  supportPhone     String?
  
  updatedAt        DateTime @default(now()) @updatedAt
}

// ============================================
// EXISTING MODELS (Unchanged)
// ============================================

model Questionnaire {
  id         String   @id @default(cuid())
  contractId String   @unique
  contract   Contract @relation(fields: [contractId], references: [id])
  responses  Json
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Review {
  id         String   @id @default(cuid())
  contractId String   @unique
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  rating     Int
  feedback   String?  @db.Text
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model File {
  id                 String   @id @default(cuid())
  filename           String
  fileUrl            String
  fileType           String
  fileSize           Int
  cloudinaryPublicId String?
  uploadedById       String
  uploadedBy         User     @relation(fields: [uploadedById], references: [id])
  entityType         String
  entityId           String
  description        String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([entityType, entityId])
  @@index([uploadedById])
}

model Payment {
  id            String          @id @default(cuid())
  provider      PaymentProvider
  reference     String          @unique
  amount        Int
  currency      String          @default("NGN")
  status        PaymentStatus
  channel       String?
  paidAt        DateTime?
  customerEmail String?
  meta          Json?
  rawPayload    Json?

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  contractId String?
  contract   Contract? @relation(fields: [contractId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reference])
  @@index([status])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      String
  title     String
  body      String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, read])
}

model TaskComment {
  id              String   @id @default(cuid())
  content         String
  isClientComment Boolean  @default(false)
  createdAt       DateTime @default(now())

  taskId String
  task   Task   @relation(fields: [taskId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])
}

model TaskUpdate {
  id            String      @id @default(cuid())
  oldStatus     TaskStatus?
  newStatus     TaskStatus?
  message       String?
  attachmentUrl String?
  timestamp     DateTime    @default(now())

  taskId String
  task   Task   @relation(fields: [taskId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])
}

model AuditLog {
  id         String   @id @default(cuid())
  actionType String
  entityType String
  entityId   String
  metaJson   Json?
  timestamp  DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id])

  @@index([entityType, entityId])
  @@index([userId])
}

model ChatChannel {
  id       String  @id @default(cuid())
  clientId String
  client   Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)
  workerId String?
  worker   User?   @relation("WorkerChats", fields: [workerId], references: [id], onDelete: SetNull)

  lastMessageAt DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  messages Message[]

  @@unique([clientId, workerId])
  @@index([clientId])
  @@index([workerId])
  @@index([lastMessageAt])
}

model Message {
  id        String      @id @default(cuid())
  channelId String
  channel   ChatChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade)

  content String    @db.Text
  read    Boolean   @default(false)
  readAt  DateTime?

  attachments Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([channelId, createdAt])
  @@index([senderId])
}
